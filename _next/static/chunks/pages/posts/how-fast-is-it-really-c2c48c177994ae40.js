(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[797],{6186:function(e,t,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/how-fast-is-it-really",function(){return r(8075)}])},8075:function(e,t,r){"use strict";r.r(t),r.d(t,{default:function(){return Post}});var i=r(1010),o=r(7582),s=r(5893),n=r(4795),a=r(4369),l=r(7139),d=r(6120),c=r(5660),h=r.n(c);r(366);var m=r(7294);function CodeBlock(e){var t=e.children;return(0,s.jsx)("pre",{className:"language-python",style:{borderRadius:8,fontSize:16,padding:16,boxShadow:"rgba(99, 99, 99, 0.2) 0px 2px 8px 0px"},children:(0,s.jsx)("code",{children:t})})}function Post(){return(0,m.useEffect)(function(){var e;(e=(0,i._)(function(){return(0,o.Jh)(this,function(e){switch(e.label){case 0:return[4,h().highlightAll()];case 1:return e.sent(),[2]}})}),function(){return e.apply(this,arguments)})()},[]),(0,s.jsx)(n.Z,{title:"How fast is it, really?",children:(0,s.jsx)(a.Z,{css:{padding:64,display:"flex",justifyContent:"center"},children:(0,s.jsxs)(a.Z,{css:{borderTop:"4px solid $blue",maxWidth:800,width:"100%",display:"flex",flexDirection:"column",gap:"$sm"},children:[(0,s.jsx)(l.Z,{weight:"bold",size:"xxl",children:"On latency, measurement, and optimization in algorithmic trading systems"}),(0,s.jsxs)(a.Z,{css:{width:"100%",display:"flex",flexDirection:"column",alignItems:"center",gap:"$sm"},children:[(0,s.jsx)(l.Z,{children:"Brett Harrison"}),(0,s.jsx)(l.Z,{children:"September 5, 2023"})]}),(0,s.jsxs)(d.Z,{size:"xl",css:{fontWeight:300,lineHeight:1.5},children:[(0,s.jsx)(l.Z,{css:{fontStyle:"italic"},children:' "The speed of light sucks." - John Carmack'}),(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),'Software engineers within the world of low-latency automated trading (colloquially known as "high-frequency trading" or HFT) obsess over speed. From purchasing private bandwidth between microwave towers to analyzing x86 instructions from different compiler versions, those with experience in this industry have seen colossal time and expense committed to the problem of optimizing code and network paths for minimal execution times.',(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"But how does one actually measure how fast a program is? To the uninitiated, it sounds like a simple task. However there are many layers of complexity in measuring the true latency of a trading system, or even defining what to measure in the first place. Understanding latencies in algorithmic trading systems can present Heisenberg-esque dilemmas, where the more code you write to measure latency the more overhead you add to your program and therefore the more inaccurate your measurements become.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"At Architect we have been using a combination techniques to measure the latency of various codepaths and processes that comprise our institutional trading technology suite. Let's explore some solutions to these problems.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"--",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Let's say you've written an algorithmic trading strategy. Your strategy reacts to market trades in an instrument, perhaps by computing a proprietary model valuation, and sends an order in that instrument provided certain conditions are met. You would like to measure the time that this reaction takes, so that you can reduce the time as much as possible. Let's use Python-style pseudocode to describe the program (although in practice it is most common to use languages like, C, C++, and Rust where optimal program latencies are required):",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsx)(CodeBlock,{children:"def on_market_trade(self, instrument, market_trade):\n    model_value = self.compute_model_value(instrument, market_trade) \n    order = self.compute_order_decision(instrument, model_value) \n    if order is not None:\n        self.send_order(order)\n"}),(0,s.jsx)("br",{}),"A reasonable place to start in understanding the latency of your critical codepath is to wrap timers around the functions doing the heavy lifting:",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsx)(CodeBlock,{children:"def on_market_trade(self, instrument, market_trade):\n    start_time = datetime.now()\n    model_value = self.compute_model_value(instrument, market_trade) order =\n<<<<<<< HEAD\n    self.compute_order_decision(instrument, model_value) \n    end_time = datetime.now()\n=======\n    self.compute_order_decision(instrument, model_value) end_time = datetime.now()\n>>>>>>> 9f9d35e (blog)\n    self.add_time_sample(end_time - start_time) \n    if order is not None: \n        self.send_order(order)\n"}),(0,s.jsx)("br",{}),"The function self.add_time_sample would add the elapsed time to a histogram that you could print statistics for at the end of your program's lifecycle, or on some regular basis based on time or number of samples observed. There are many issues with the above approach:",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsxs)("ol",{children:[(0,s.jsx)("li",{children:"It measures the time required to compute the order decision, but does not include the time it takes to send the actual order."}),(0,s.jsx)("li",{children:"It observes computation time on every market trade, rather than just the trades that result in orders -- this can bias results because the most interesting times to send orders may be the ones where your program is running the slowest due to volume of market events or other factors."}),(0,s.jsx)("li",{children:"datetime.now() itself is a slow, expensive function that can impact the runtime speed and memory profile of the code above, which adds up if your program is already operating on a microsecond-timescale. The typical way to fix this last issue is to use native performance counters that most programming language have primitives to access."})]}),(0,s.jsx)("br",{}),"Here's a new code sample that attempts to fix the above:",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsx)(CodeBlock,{children:"def on_market_trade(self, instrument, market_trade):\n    start_time = time.perf_counter_ns()\n    model_value = self.compute_model_value(instrument, market_trade) \n    order = self.compute_order_decision(instrument, model_value) \n    if order is not None:\n        self.send_order(order) \n        end_time = time.perf_counter_ns() \n        self.add_time_sample(end_time - start_time)"}),(0,s.jsx)("br",{}),"This is an improvement, but are we really getting at the full latency of the trading system? The above doesn't include significant elements of the critical path, including the time to parse the market trade update, or anything involving network I/O. Let's take a step back and trace a market data update through the complete critical path of the automated trading system (ATS):",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsxs)("ol",{children:[(0,s.jsx)("li",{children:"Network packet containing the market trade hits the network card of the box where the ATS is running (sent from the exchange)"}),(0,s.jsx)("li",{children:"The packet is passed to the runtime of the ATS"}),(0,s.jsx)("li",{children:"The ATS parses the bytes of the packet to pull out necessary fields (such as trade price or trade size)"}),(0,s.jsx)("li",{children:"The ATS computes a model value and makes a decision to send an order"}),(0,s.jsx)("li",{children:"The internal memory representation of the order is converted to the protocol of the exchange that the order is being sent to"}),(0,s.jsx)("li",{children:"The ATS makes function calls to pass the order bytes to the network card of the box for sending"}),(0,s.jsx)("li",{children:"The network card of the box sends the order bytes to the exchange"})]}),(0,s.jsx)("br",{}),"(There are many details missing from the above, such as the multiple methods of going from steps 1 to 2 and 6 to 7, but we are omitting those for simplicity for now.)",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"The code sample above is only measuring steps 4, 5, and 6. I have seen many real-world instances where 90% or more of the full latency profile was present in 1, 2, 6, and 7. A large chunk of latency could be incurred in step 3 if performed uncarefully, or if there is any order-book-building necessary in steps 3 and 4.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"To truly capture all seven steps, you can set up this alternative method for measuring latency:",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsxs)("ul",{children:[(0,s.jsx)("li",{children:"Write a program that simulates the exchange market data, by sending random market trade events on a timer"}),(0,s.jsx)("li",{children:"Have that same program simulate the exchange itself by receiving orders in the exchange's native protocol"}),(0,s.jsx)("li",{children:"Have the simulator timestamp the market trades with the current time right before sending"}),(0,s.jsx)("li",{children:"Configure the ATS to receive data from the simulator and send orders to the simulator. Have the ATS attach the exchange trade timestamp on the order it sends to the exchange, or if that's not possible in the protocol have it record a mapping from order id to exchange trade timestamp"}),(0,s.jsx)("li",{children:"Have the simulator write down the timestamp when it receives orders from the ATS. From either the data on the order itself or from the ATS's mapping of order id to exchange trade timestamp, compute the difference between market trade send time and order receive time."})]}),(0,s.jsx)("br",{}),"While the above does completely capture the full critical path, it provides too conservative an estimate of latency: it also captures a similar codepath for the simulator itself! To get closer to the right answer, you can write another simulation Exchange and also a simulation ATS that just ping/pongs a single timestamp back and forth without any protocol translation, model building, order sending, etc. This provides a baseline for inter-program latency that could be subtracted from the above experiment.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"The as-close-as-possible-to-perfect solution involves a much more advanced setup, where modern switching hardware is used to replicate packet traffic in and out of the box and the raw network packets are parsed and correlated for timestamping. But I'll leave those details for a future post.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Writing fast algorithmic trading system code is hard. Measuring it properly is even harder. At Architect we have created institutional-grade low-latency trading software for both regulated derivatives and digital assets, so that you can let us do the work for you.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{})]})]})})})}},4795:function(e,t,r){"use strict";r.d(t,{Z:function(){return BlogPost}});var i=r(5893),o=r(4369),s=r(1624),n=r(9065),a=r(5621),l=r(8139),d=r(1614);function BlogHero(e){var t=e.title;return(0,i.jsxs)("header",{style:{height:"70vh",display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",color:"white",position:"relative",overflow:"hidden",zIndex:1},children:[(0,i.jsx)(HeroImage,{src:"/images/blog_hero.png"}),(0,i.jsx)(HeroText,{text:t})]})}function HeroImage(e){var t=e.src;return(0,i.jsx)(l.Z,{src:t,css:{opacity:1,position:"absolute",minWidth:"100%",minHeight:"100%",width:"auto",height:"auto",objectFit:"cover",zIndex:-1}})}function HeroText(e){var t=e.text;return(0,i.jsx)(o.Z,{css:{paddingTop:"100px",height:"100%",width:"100%",position:"absolute",top:0,left:0,display:"flex",alignItems:"center"},children:(0,i.jsx)(d.Z,{children:(0,i.jsxs)(o.Z,{css:{display:"flex",flexDirection:"column",gap:"$lg"},children:[(0,i.jsx)(a.xv,{css:{color:"$blue",maxWidth:"60%",fontWeight:700,fontSize:"max(40px, min(min(80px, 8vw), 6vh))",marginLeft:"10%"},children:"Architect Blog"}),(0,i.jsx)(a.xv,{css:{color:"white",maxWidth:"80%",fontWeight:700,fontSize:"max(60px, min(min(120px, 12vw), 10vh))",marginLeft:"10%"},children:t})]})})})}function BlogPost(e){var t=e.title,r=e.children;return(0,i.jsxs)(o.Z,{children:[(0,i.jsx)(n.Z,{}),(0,i.jsx)(BlogHero,{title:t}),(0,i.jsx)(i.Fragment,{children:r}),(0,i.jsx)(s.Z,{})]})}},6120:function(e,t,r){"use strict";var i=r(2508);t.Z=(0,i.zo)("p",{variants:{color:{default:{color:"$light"},dark:{color:"$dark"},gray:{color:"$gray"},blue:{color:"$blue"}},weight:{light:{fontWeight:300},regular:{fontWeight:400},medium:{fontWeight:500},bold:{fontWeight:700}},size:{xs:{fontSize:12},s:{fontSize:14},m:{fontSize:16},l:{fontSize:18},xl:{fontSize:24},xxl:{fontSize:32}},variant:{uppercase:{textTransform:"uppercase"},capitalize:{textTransform:"capitalize"}},align:{right:{textAlign:"right"}}}})}},function(e){e.O(0,[409,143,804,806,621,359,774,888,179],function(){return e(e.s=6186)}),_N_E=e.O()}]);